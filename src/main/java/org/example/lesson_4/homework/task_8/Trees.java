package org.example.lesson_4.homework.task_8;

/**
 * функция, которая принимает корень бинарного дерева поиска и целочисленное значение
 * и добавляет это значение в дерево с сохранением свойств BST.
 */
public class Trees {
//    Структура данных, организованная в виде иерархии, где каждый элемент называется узлом.
//    Узел содержит: Значение (данные узла) и Ссылки на дочерние узлы.
//    Самый верхний узел называется корнем, а узлы без дочерних узлов — листовыми.
//    Деревья полезны для организации данных с иерархией или для быстрого поиска.

//    Используется для:
//    - Поиск: Бинарные деревья поиска быстро находит данные, в среднем O(log n)
//    - Сортировка: TreeSet и TreeMap элементы в отсортированном виде
//    - Иерархическое представление: XML/HTML, организационные структуры и др.
//    - Эффективное управление данными: Для задач, где требуется балансировка (например, красно-черные деревья или AVL-деревья).


//    Реализации:
//    - TreeSet: Set, основанная на красно-черном дереве. Элементы автоматически упорядочены, значения уникальные.
//    - TreeMap: Map, основанная на красно-черном дереве. Ключи отсортированы по естественному порядку или с использованием компаратора.
//    - Binary Search Tree (BST): упрощенная структура, в которой для каждого узла:
//  	- Все значения в левом поддереве меньше, чем значение узла.
//	    - Все значения в правом поддереве больше.

//    Когда использовать деревья?
//	1.	TreeSet: Уникальные элементы, которые нужно упорядочить. Быстрый поиск, вставка и удаление.
//	2.	TreeMap: Ассоциативные массивы, где ключи должны быть отсортированы.
//  3.	Самописные деревья: Если вам нужно настраивать поведение (например, специальные операции с узлами).

}
